<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=430" />
  <title>민후와 대화하기</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
  <style>
    /* 기본 스타일 */
    body {
      font-family: 'KoPubWorld Dotum', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #ffffff;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: calc(100vh - 40px);
      box-sizing: border-box;
    }
    .container {
      width: 100%;
      max-width: 400px;
      text-align: center;
    }
    .talk-heading {
      font-size: 22px;
      font-weight: bold;
      margin-top: 30px;
      margin-bottom: 10px;
    }
    .guide-text {
      font-size: 15px;
      color: #555;
      margin-bottom: 30px;
      line-height: 1.6;
    }
    #mic-visualizer { /* P5.js가 사용할 실제 캔버스 */
      display: block;
      margin: 0 auto 30px auto;
      width: 280px; 
      height: 280px; 
      background-color: #f0f0f0; /* P5 배경이 투명할 경우 대비 */
      border-radius: 50%; /* 캔버스 자체도 둥글게 (선택 사항) */
      /* overflow: hidden; P5가 캔버스 크기를 직접 제어하므로 불필요할 수 있음 */
    }
    .banner-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin-top: 20px;
    }
    .banner-btn {
      width: 300px;
      height: 55px;
      font-size: 17px;
      font-weight: bold;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .btn-talk {
      background-color: #FAF07F; 
      color: #333; 
    }
    .btn-talk.active {
      background-color: #FFB6C1; 
      color: white;
    }
    .btn-process { /* 이전 process-btn 클래스명 유지 */
      background-color: #D2E9FF; 
      color: #333;
    }
    /* .btn-interaction.analysis-ready 와 같은 다른 버튼 상태 스타일은 analysis.html 또는 다른 페이지에 있을 수 있음 */

    .transcript-box {
      margin-top: 30px;
      padding: 15px;
      background-color: #f9f9f9;
      border-radius: 8px;
      min-height: 50px; /* 이전 talk.html의 값 유지 */
      font-size: 15px;
      color: #333;
      line-height: 1.5;
      text-align: left;
      border: 1px solid #eee;
      width: 100%;
      box-sizing: border-box;
      white-space: pre-wrap; /* 여러 줄 표시를 위해 추가 */
    }
    .tts-warning {
      color: #d9534f;
      font-size: 0.9em;
      padding: 10px;
      background-color: #f2dede;
      border: 1px solid #ebccd1;
      border-radius: 4px;
      margin-bottom: 15px;
      text-align: center;
    }
    /* @import url('https://webfontworld.github.io/kopus/KoPubWorldDotum.css'); */
  </style>
</head>
<body>
  <main class="container">
    <div id="tts-status-container"></div>
    <h1 class="talk-heading">민후, 지금 기분은 어때?</h1>
    <p id="guide-text" class="guide-text">대화하기 버튼을 눌러서 이야기해보자.<br>다 마치면 [대화 분석하기]를 눌러줘.</p>

    <canvas id="mic-visualizer"></canvas>

    <div class="banner-wrapper">
      <button id="talk-btn" class="banner-btn btn-talk">대화하기</button>
      <button id="process-btn" class="banner-btn btn-process">대화 분석하기</button> 
    </div>

    <div id="transcript" class="transcript-box">여기에 음성 인식 결과가 표시됩니다.</div>
  </main>

  <script type="module">
    import { startSTT, stopSTT } from './js/stt.js';
    import { startTTS } from './js/tts.js'; // TTS 사용 시 주석 해제
    import { getGptResponse } from './js/gpt-dialog.js'; // GPT 사용 시 주석 해제
    // visualizer_p5.js로 변경
    import { startVisualizer, stopVisualizer } from './js/visualizer_p5.js';

    const talkBtn = document.getElementById('talk-btn');
    // 'process-btn' 또는 'interaction-btn' 등 실제 HTML의 ID와 일치시켜야 함
    const processBtn = document.getElementById('process-btn'); 
    const transcriptEl = document.getElementById('transcript');
    const guideTextEl = document.getElementById('guide-text'); // 가이드 텍스트 요소
    const canvasForVisualizer = document.getElementById('mic-visualizer'); // P5.js용 캔버스
    const ttsStatusContainer = document.getElementById('tts-status-container');

    let isRecording = false;
    let ttsGenerallySupported = true;
    let conversationHistory = []; // 연속 대화를 위해 필요
    let turnCount = 0; // 연속 대화를 위해 필요
    const MAX_TURNS_BEFORE_ANALYSIS = 3; // 연속 대화를 위해 필요

    window.addEventListener('DOMContentLoaded', () => {
       // talk.html 로드 시 localStorage에서 이어할 대화가 있는지 확인
       const continueMode = localStorage.getItem('conversationMode');
       const historyToContinue = localStorage.getItem('continueConversationHistory');

       if (continueMode === 'continue' && historyToContinue) {
           try {
               conversationHistory = JSON.parse(historyToContinue);
               // turnCount = 이전 턴 수 (필요시 저장 및 로드)
               updateTranscriptDisplay("이전 대화에 이어서 시작합니다.", "system_message");
               guideTextEl.innerHTML = "이전 대화에 이어서 이야기해주세요.<br>[대화하기]를 누르거나, [숨 돌리기]로 AI의 답변을 들어보세요.";
           } catch (e) {
               console.error("이어하기 대화 기록 파싱 오류:", e);
               conversationHistory = []; // 오류 시 초기화
               updateTranscriptDisplay("대화하기 버튼을 눌러 민후와 이야기해보세요!", "initial_empty");
           }
           localStorage.removeItem('continueConversationHistory');
           localStorage.removeItem('conversationMode');
       } else {
           localStorage.removeItem('userSpeech');
           localStorage.removeItem('fullConversation'); // 이전 분석용 대화 기록 삭제
           updateTranscriptDisplay("대화하기 버튼을 눌러 민후와 이야기해보세요!", "initial_empty");
       }
       
       canvasForVisualizer.width = 280; // P5 Canvas 크기 명시적 설정
       canvasForVisualizer.height = 280;

       if (!window.speechSynthesis) {
           ttsGenerallySupported = false;
           // (TTS 미지원 UI 처리 - 이전 코드와 동일)
       }
    });
    
    // 대화 내용 표시 함수 (analysis.html과 유사하게, 또는 더 간단하게)
    function updateTranscriptDisplay(newText = "", role = "system_message") {
        if (role === "user" && newText) {
            conversationHistory.push({ role: "user", content: newText });
        } else if (role === "assistant" && newText) {
            conversationHistory.push({ role: "assistant", content: newText });
        } else if (role === "system_error" && newText) {
             conversationHistory.push({ role: "system", content: `[오류] ${newText}` });
        } else if (role === "system_message" && newText) {
             conversationHistory.push({ role: "system", content: `[안내] ${newText}` });
        }


        let displayHtml = "";
        conversationHistory.forEach(msg => {
            const speaker = msg.role === 'user' ? '민후' : (msg.role === 'assistant' ? 'AI 친구' : '안내');
            const safeContent = (msg.content || "").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            displayHtml += `<p><strong>${speaker}:</strong> ${safeContent}</p>`;
        });
        
        if (conversationHistory.length === 0 && role !== "initial_empty") {
             transcriptEl.innerHTML = "<p>대화하기 버튼을 눌러 민후와 이야기해보세요!</p>";
        } else if (role === "initial_empty") {
             transcriptEl.innerHTML = "<p>여기에 대화 내용이 표시됩니다.</p>";
        }
        else {
            transcriptEl.innerHTML = displayHtml;
        }
        transcriptEl.scrollTop = transcriptEl.scrollHeight;
    }


    // "대화하기" / "잠깐 쉬기" 버튼 토글 로직
    talkBtn.addEventListener('click', async () => {
      if (!isRecording) {
        isRecording = true;
        talkBtn.textContent = '잠깐 쉬기';
        talkBtn.classList.add('active');
        // 현재 대화 기록을 유지하면서 마이크 준비 메시지 추가
        transcriptEl.innerHTML = conversationHistory.map(msg => `<p><strong>${msg.role === 'user' ? '민후' : 'AI 친구'}:</strong> ${msg.content.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>`).join('') + "<p>[안내] 마이크 준비 중...🎙️</p>";
        transcriptEl.scrollTop = transcriptEl.scrollHeight;
        try {
          await startVisualizer(canvasForVisualizer); // P5.js 시각화 시작
          startSTT((text) => {
            if (text) {
              localStorage.setItem('userSpeech', text); // 현재 발화 저장
              // STT 결과를 즉시 대화창에 반영 (사용자 발화로)
              transcriptEl.innerHTML = conversationHistory.map(msg => `<p><strong>${msg.role === 'user' ? '민후' : 'AI 친구'}:</strong> ${msg.content.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>`).join('') + `<p><strong>민후 (말하는 중):</strong> "${text.replace(/</g, "&lt;").replace(/>/g, "&gt;")}"</p>`;
              transcriptEl.scrollTop = transcriptEl.scrollHeight;
            } else if (isRecording) {
              updateTranscriptDisplay("음... 잘 못 들었어. 다시 말해줄래?", "system_message");
            }
          });
          updateTranscriptDisplay("듣고 있어요... 말해주세요! 😊", "system_message");
        } catch (err) {
          isRecording = false;
          talkBtn.textContent = '대화하기';
          talkBtn.classList.remove('active');
          updateTranscriptDisplay(`마이크를 시작하지 못했어요. 😥 권한을 확인하고 다시 시도해주세요. (${err.message})`, "system_error");
          stopVisualizer();
        }
      } else { // 녹음 중지 ("잠깐 쉬기" 클릭)
        isRecording = false;
        talkBtn.textContent = '대화하기';
        talkBtn.classList.remove('active');
        stopSTT();
        stopVisualizer();
        const lastUserSpeech = localStorage.getItem('userSpeech');
        if (lastUserSpeech) {
             // "숨 돌리기" 버튼을 누르기 전까지는 userSpeech를 history에 넣지 않음
             updateTranscriptDisplay(`"${lastUserSpeech}" 라고 말했구나! 이제 [숨 돌리기]를 눌러 AI 친구와 이야기하거나, [대화하기]를 눌러 더 말할 수 있어.`, "system_message");
        } else {
            updateTranscriptDisplay("대화를 잠시 멈췄어요.", "system_message");
        }
      }
    });

    // "숨 돌리기" 또는 "대화 분석하기" 버튼 로직 (이전 talk.html의 interactionBtn 로직 참고)
    processBtn.addEventListener('click', async () => {
        // 이 버튼의 역할이 "대화 분석하기"로 고정된 경우 (이전 코드)
        // 또는 "숨 돌리기" -> "대화 분석하기"로 변하는 경우 (더 복잡한 로직)
        // 현재 코드에서는 "대화 분석하기"로 가정하고 analysis.html로 데이터 전달

        if (isRecording) {
            isRecording = false;
            talkBtn.textContent = '대화하기';
            talkBtn.classList.remove('active');
            stopSTT();
            stopVisualizer();
        }

        const currentUserSpeech = localStorage.getItem('userSpeech');
        if (currentUserSpeech) { // 마지막 발화가 있다면 대화 기록에 추가
            updateTranscriptDisplay(currentUserSpeech, "user");
            localStorage.removeItem('userSpeech'); // 처리했으므로 삭제
        }

        if (conversationHistory.length === 0) {
            alert("분석할 대화 내용이 없어요. 먼저 '대화하기' 버튼을 눌러 이야기를 녹음해주세요.");
            updateTranscriptDisplay("분석할 대화 내용이 없어요.", "system_message");
            return;
        }
        
        // 전체 대화 기록을 analysis.html로 전달
        localStorage.setItem('fullConversation', JSON.stringify(conversationHistory));
        // P5.js 시각화에서 저장한 오디오 레벨도 가져올 수 있음
        const lastAmplitude = localStorage.getItem('currentAmplitude');
        if (lastAmplitude) {
            localStorage.setItem('analysisAudioLevel', lastAmplitude);
        }

        console.log("🚀 대화 분석하기 버튼 클릭됨. analysis.html로 이동합니다.");
        window.location.href = 'analysis.html';
    });

    // TTS 시도 및 오류 처리 헬퍼 함수
    async function attemptTTS(textToSpeak) {
        if (!ttsGenerallySupported || !textToSpeak || textToSpeak.trim() === "" || textToSpeak.trim() === "...") {
            return;
        }
        try {
            await startTTS(textToSpeak); // startTTS가 Promise를 반환한다고 가정
        } catch (ttsError) {
            console.warn(`TTS 재생 중 오류: "${textToSpeak.substring(0,30)}..."`, ttsError.message);
            // (TTS 미지원 UI 처리 - 이전 코드와 동일)
        }
    }

  </script>
</body>
</html>
